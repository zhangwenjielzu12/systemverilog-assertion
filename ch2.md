# SVA 模拟方法论

**协议的析取和断言的开发过程**  
**基于断言的验证(ABV)**

块的穷举验证能提前发现边缘缺陷(corner case bugs)  
SVA 可以很容易地用来有效地测试独立设计块。在模块级，模拟工作量比较少，因此缺陷容易被跟踪并快速修复  
**SVA 进行块级中的一些建议：**

1. SVA 所有为块级设计而写检验都应该是内嵌的。块级断言经常要访问设计的内部寄存器，因此把检验内嵌到设计模块更为有效率。
2. 模块级的 SVA 检验的引用应该由设计模块内定义的参数来控制。这样，根据模拟的不同需求，可以自由地打开或关闭这些检验。
3. 模块级的 SVA 检验的严重级别应该由设计模块内定义的参数来控制。SVA 里默认的严重级别将打印一个出错信息，然后继续模拟
4. 每个模块级的 SVA 检验都应该被执行并覆盖到。所有模块级检验一定要至少有一次真正的成功，这是必需的

**SVA 进行系统级验证时的建议：**

1. 由于单个块的内部功能已经仔细验证过，所以默认状态下，在系统级验证时不把块级断言包含进去。这么做主要是为了提高性能。
2. 如果性能不是瓶颈，默认情况下，在系统级验证中把块级断言包含进去。系统接口提供了更加真实的和一些期望之外的输入情况，而模块级断言要能对此作出正确的反应。
3. 如果有断言失败，验证环境要提供机制来激活模块级断言。
4. 在系统级，要写一些新的断言来验证系统的连接，这些检查更应该关注接口规则而不是块内部细节。

在系统级模拟中，最顶层的模块应该配置参数设定这样可以关闭所有的块级断言

在基本的设计块中，用“ifdef-endif”结构可以有条件地把 SVA 检验包括进去。通过条件编译 SVA 的代码，用户可以在模块的所有实例中做这些检验，也可以不做这些检验。这个方法的不足之处是它是一个全局控制机制，会影响所有的模块级检验。通过使用参数，这个不足可以被克服，用户在模拟中可以更加灵活地选择需要的块级检验。

为动态模拟写的 SVA 检验的效果仍然依赖于输入激励  
从 SVA 收集来的覆盖信息能有效地用来建立反应验证环境（reactive verification environment）  
**可以利用功能覆盖的信息来终止一个模拟（通过检验变量值得行为）**

在进行功能覆盖率时，SVA 并不是唯一的选择.如果功能覆盖涉及到穷举测试计划的覆盖点，那么使用支持面向对象编程的测试平台语言，效率会更高

**SVA 可以用来创建日志文件** 调用任务或函数扩展了 SVA 检验器的功能

块级断言应该成为设计的一部分，这样有助于 FPGA 的原型测试

## SVA 模拟方法小结

1. SVA 对测试平台环境的补充使动态模拟的效率更高。
2. 设计者非常熟悉设计的内部功能，因此，他们应该把 SVA 检验器内嵌到相应的设计模块中。
3. 验证工程师负责集成和验证系统，他们应该添加系统级断言，来彻底验证接口协议。
4. 验证工程师应该能从验证环境控制或配置块级断言(如果需要，他能打开或关闭断言)。
5. 采用 SVA，几乎不费吹灰之力就可以收集到功能覆盖的信息。应该有效利用这些信息来建立反应测试平台。
6. 由于 SVA 在模拟全过程中监视设计的协议，它能用来创建信息丰富的日志文件。
7. 按照**可综合的编码风格编写 SVA 检验器，使 SVA 检验器能成为网表的一部分**，可以用于调试原型或混合模拟中的失败。
